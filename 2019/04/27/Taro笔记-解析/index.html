<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="web前端开发, Hexo, webpack, Nodejs, Reactjs, Vuejs"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>Taro笔记(解析) - B_B</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com"><span>Github</span></a></li><li><a href="https://www.v2ex.com/"><span>V2EX</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">Taro笔记(解析)</h1><ul class="meta"><li><i class="icon icon-author"></i>BensonChen</li><li><i class="icon icon-clock"></i>18 Minutes</li><li><i class="icon icon-calendar"></i>April 27, 2019</li></ul></div></div><div class="article-content" style="max-width:1024px"><p>Taro，京东凹凸团队搞的一个多端框架（小程序，rn，h5，）遵循 React 语法规范，组件生命周期与 React 保持一致，同时支持TS。<br>Taro 还是以小程序为基础，封装了一系列的组件，并且可以集成redux来干状态管理。<br>安装使用过程看文档：<a href="https://nervjs.github.io/taro/docs/GETTING-STARTED.html。" target="_blank" rel="noopener">https://nervjs.github.io/taro/docs/GETTING-STARTED.html。</a><br>（ps:本人看了写原生小程序开发文档，果断放弃原生的坑）</p>
<h2 id="记一下使用心得"><a href="#记一下使用心得" class="headerlink" title="记一下使用心得"></a>记一下使用心得</h2><p>1.Taro封装的组件用来开发小程序应该是能满足90%的场景和需求，如果满足不了，请另想办法。<br>2.路由传参，复杂参数就不要想通过这种方式了。<br>3.毕竟是对小程序的支持比较好，在H5和RN上你可能会遇到一些没头脑的问题。<br>4.可以干异步编程，这个是个不错的更新。<br>5.消息机制用好了，可以解决大部分问题，但这个应该只是个标配。<br>好吧，我编不出来了。</p>
<h2 id="写一点Taro核心"><a href="#写一点Taro核心" class="headerlink" title="写一点Taro核心"></a>写一点Taro核心</h2><p>小程序和WEB乃至RN在API和组件上有着巨大的差异，不能简单的通过直译的方式将 <view> 转化成 <div> 。因此Taro干了一套标准来处理这个问题。</div></view></p>
<blockquote>
<p>这一套标准主要以三个部分组成，包括标准运行时框架、标准基础组件库、标准端能力 API，其中运行时框架和 API 对应 @taro/taro，组件库对应 @tarojs/components，通过在不同端实现这些标准，从而达到去差异化的目的。<br> —摘自 《Taro 多端开发实现原理与项目实战》第8章</p>
</blockquote>
<p>同时作者也在上文中描述了Taro为什么会以小程序作为组件和API标准的原因。</p>
<h2 id="Taro的灵魂-taro-build"><a href="#Taro的灵魂-taro-build" class="headerlink" title="Taro的灵魂 taro build"></a>Taro的灵魂 taro build</h2><p>少喝水。</p>
<p>taro build 是实现多端编译的核心，我甚至把他看做整个Taro和核心。简单的讲，把一种结构化语言转化成另外一种，要经历至少三个步骤。<br>1.代码结构化转化（把代码结构转化成抽象语法树，然后进行遍历和替换，最后根据新的规则生成代码）；<br>2.babel编译转换（Taro也主要使用了这个方式，主要针对于API的语法规范）；<br>3.解析配置文件；<br>写的真TM简单。。。接着看Taro源码。</p>
<h2 id="先看-taro-cli这个脚手架"><a href="#先看-taro-cli这个脚手架" class="headerlink" title="先看 taro-cli这个脚手架"></a>先看 taro-cli这个脚手架</h2><p>我们对Taro的使用还是基于脚手架工具的，我们分析一下它。<br>我们通过项目package.json文件可以看到，对项目的操作命令实际上都是 taro 来执行。所以至关重要的是分析taro命令。通过阅读 taro-cli 的源码可知，taro命令是我们在安装 taro-cli 工具时，它将taro命令搞到了环境PATH中，以便调用（由于taro-cli的package.json中指定了bin对象，意思就是为其命令和具体的运行体做一个软连接，参考<a href="http://www.cnblogs.com/tzyy/p/5193811.html#_h1_11）。" target="_blank" rel="noopener">http://www.cnblogs.com/tzyy/p/5193811.html#_h1_11）。</a></p>
<p><image src="https://cdn.nlark.com/yuque/0/2019/png/197796/1555669363481-2e8a4ef4-8277-4e57-8141-bef9cbb92f2f.png"><br>我们可以看到核心就一个 taro build 这个命令实际上是调用 taro-cli 的 taro 子命令 build，我们来看一下关键源码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;getPkgVersion&#125; = <span class="built_in">require</span>(<span class="string">'../src/util'</span>)</span><br><span class="line"></span><br><span class="line">program.version(getPkgVersion())</span><br><span class="line">  .usage(<span class="string">'&lt;command&gt; [options]'</span>)</span><br><span class="line">  .command(<span class="string">'init [projectName]'</span>, <span class="string">'Init a project with default templete'</span>)</span><br><span class="line">  .command(<span class="string">'build'</span>, <span class="string">'Build a project with options'</span>)</span><br><span class="line">  .command(<span class="string">'update'</span>, <span class="string">'Update packages of taro'</span>)</span><br><span class="line">  .command(<span class="string">'convert'</span>, <span class="string">'Convert weapp to taro'</span>)</span><br><span class="line">  .command(<span class="string">'info'</span>, <span class="string">'Diagnostics Taro env info'</span>)</span><br><span class="line">  .parse(process.argv)</span><br></pre></td></tr></table></figure></image></p>
<p>commander可以根据子命令自动引导到以特定格式命名的命令执行文件，文件名的格式是 [command]-[subcommand]。例如 taro build 就会去执行 taro-build 这个文件。<br>so，当 npm run (taro build –type weapp/taro build –type h5等) 命令到达上面文件后会被转发到同级目录下的 taro-build 文件去执行。<br>接下来我们就要去探究更加详细的过程了。</p>
<h3 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h3><p>如果看到这里了，可能会和我一样有个疑问。到底是什么在支撑 build 功能的执行。如果看过 taro-build 的源码，会发现（PS：发现个P，作者不看其他文字才不会get到这个点）顶部有一句 #!/usr/bin/env node 。</p>
<p><image src="https://cdn.nlark.com/yuque/0/2019/png/197796/1555916139023-264121dd-15eb-4742-9bd4-1702d8f6a343.png"><br>OMG，居然是它，居然是一个我从来都没见过的东西，特意查了一下。这个东东分两部分 #! URL，#! 学名叫做 Shebang 是Linux 上的命令。<br>1.如果脚本文件中没有#!这一行，那么它执行时会默认用当前Shell去解释这个脚本(即：$SHELL环境变量）。<br>2.如果#!之后的解释程序是一个可执行文件，那么执行这个脚本时，它就会把文件名及其参数一起作为参数传给那个解释程序去执行。<br>3.如果#!指定的解释程序没有可执行权限，则会报错“bad interpreter: Permission denied”。<br>4.如果#!指定的解释程序不是一个可执行文件，那么指定的解释程序会被忽略，转而交给当前的SHELL去执行这个脚本。<br>5.如果#!指定的解释程序不存在，那么会报错“bad interpreter: No such file or directory”。注意：#!之后的解释程序，需要写其绝对路径（如：#!/bin/bash），它是不会自动到$PATH中寻找解释器的。</image></p>
<p><image src="https://cdn.nlark.com/yuque/0/2019/png/197796/1555916626897-d7d563b7-05b1-4498-8058-124a9dbb44c0.png"><br>可执行文件？ 卧槽，是node，是 usr/bin/env 下面的node。但是 win 呢？image.png</image></p>
<p><image src="https://cdn.nlark.com/yuque/0/2019/png/197796/1555916943905-2852d7c6-fcd7-48fb-b477-9a1bb449221b.png"><br>我推测是直接当前shell就干了吧。</image></p>
<h3 id="src-build"><a href="#src-build" class="headerlink" title="src/build"></a>src/build</h3><p>tart-bulid文件中有一句 const build = require(‘../src/build’)，我们又去 <a href="https://github.com/NervJS/taro/blob/master/packages/taro-cli/src/build.js" target="_blank" rel="noopener">src/build</a> 下面看。<br>暂时不看了，里面没啥营养，就是对环境，条件，编译方法做出判断和约定。行吧，搬运一点吧。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> Util.BUILD_TYPES.H5:</span><br><span class="line">      buildForH5(&#123; watch &#125;)</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> Util.BUILD_TYPES.H5:</span><br><span class="line">      buildForH5(&#123; watch &#125;)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Util.BUILD_TYPES.WEAPP:</span><br><span class="line">      buildForWeapp(&#123; watch &#125;)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Util.BUILD_TYPES.SWAN:</span><br><span class="line">      buildForSwan(&#123; watch &#125;)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Util.BUILD_TYPES.ALIPAY:</span><br><span class="line">      buildForAlipay(&#123; watch &#125;)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Util.BUILD_TYPES.TT:</span><br><span class="line">      buildForTt(&#123; watch &#125;)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Util.BUILD_TYPES.RN:</span><br><span class="line">      buildForRN(&#123; watch &#125;)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Util.BUILD_TYPES.UI:</span><br><span class="line">      buildForUILibrary(&#123; watch &#125;)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Util.BUILD_TYPES.PLUGIN:</span><br><span class="line">      buildForPlugin(&#123;</span><br><span class="line">        watch,</span><br><span class="line">        platform: buildConfig.platform</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(chalk.red(<span class="string">'输入类型错误，目前只支持 weapp/h5/rn/swan/alipay/tt 六端类型'</span>))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>​这里选个buildForWeapp来看看，我们进到 <a herf="https://github.com/NervJS/taro/blob/master/packages/taro-cli/src/weapp.js">buildForWeapp</a> 文件。<br>ok，le’t go</p>
<p><image src="https://cdn.nlark.com/yuque/0/2019/png/197796/1555918088534-2c7d60b1-931d-4491-9b08-05ea9fe412de.png"><br>entered </image></p>
<p><image src="https://cdn.nlark.com/yuque/0/2019/png/197796/1555918132671-94a6d61d-53e3-4b43-b944-09d4d0e1694f.png"></image></p>
<p><image src="https://cdn.nlark.com/yuque/0/2019/png/197796/1555918435424-01f95d64-795b-4f18-a10a-296250072a1c.png"></image></p>
<p><image src="https://cdn.nlark.com/yuque/0/2019/png/197796/1555918449741-bb3f21c3-745f-40d9-bba2-5eea7cd23d42.png"></image></p>
<p><image src="https://cdn.nlark.com/yuque/0/2019/png/197796/1555918465445-03960ffb-1491-4d8c-882f-29e8ef3c37f9.png"><br>找到关键了————————————————————–<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">build</span> (<span class="params">&#123; watch, adapter, envHasBeenSet = false &#125;</span>) </span>&#123;</span><br><span class="line">  process.env.TARO_ENV = adapter</span><br><span class="line">  <span class="keyword">if</span> (!envHasBeenSet) isProduction = process.env.NODE_ENV === <span class="string">'production'</span> || !watch</span><br><span class="line">  buildAdapter = adapter</span><br><span class="line">  outputFilesTypes = Util.MINI_APP_FILES[buildAdapter]</span><br><span class="line">  <span class="comment">// 可以自定义输出文件类型</span></span><br><span class="line">  <span class="keyword">if</span> (weappConf.customFilesTypes &amp;&amp; !Util.isEmptyObject(weappConf.customFilesTypes)) &#123;</span><br><span class="line">    outputFilesTypes = <span class="built_in">Object</span>.assign(&#123;&#125;, outputFilesTypes, weappConf.customFilesTypes[buildAdapter] || &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  constantsReplaceList = <span class="built_in">Object</span>.assign(&#123;&#125;, constantsReplaceList, &#123;</span><br><span class="line">    <span class="string">'process.env.TARO_ENV'</span>: buildAdapter</span><br><span class="line">  &#125;)</span><br><span class="line">  buildProjectConfig()</span><br><span class="line">  <span class="keyword">await</span> buildFrameworkInfo()</span><br><span class="line">  copyFiles()</span><br><span class="line">  appConfig = <span class="keyword">await</span> buildEntry()</span><br><span class="line">  <span class="keyword">await</span> buildPages()</span><br><span class="line">  <span class="keyword">if</span> (watch) &#123;</span><br><span class="line">    watchFiles()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure></image></p>
<p>首先经历一个工具配置的过程 buildProjectConfig，帮你把你的小程序配置文件生成好，这个一步操作不多，主要是你再开发环境下的配置文件基本是基于微信小程序标准的，差距不会太大。<br>然后 buildFrameworkInfo ，这个是对百度小程序的一个处理。生产一个文件，具体不详，暂时也不想了解。<br>copyFiles应该也是生成配置文件相关。<br>buildEntry 这个是从入口文件开始打包，里面用了 wxTransformer ，这个应该就是taro定义的小程序转化的配置头文件</p>
<h2 id="tarojs-components"><a href="#tarojs-components" class="headerlink" title="tarojs/components"></a>tarojs/components</h2><p>这里面封装的是Taro的组件，SO用的东西都是这里来的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> View &#125; <span class="keyword">from</span> <span class="string">'./components/view'</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> Block &#125; <span class="keyword">from</span> <span class="string">'./components/block'</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> Image &#125; <span class="keyword">from</span> <span class="string">'./components/image'</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> Text &#125; <span class="keyword">from</span> <span class="string">'./components/text'</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> Switch &#125; <span class="keyword">from</span> <span class="string">'./components/switch'</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> Button &#125; <span class="keyword">from</span> <span class="string">'./components/button'</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> Icon &#125; <span class="keyword">from</span> <span class="string">'./components/icon'</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> Radio &#125; <span class="keyword">from</span> <span class="string">'./components/radio'</span></span><br><span class="line"><span class="comment">//  ...  还有很多自行脑补</span></span><br></pre></td></tr></table></figure></p>
<h2 id="tarojs-taro"><a href="#tarojs-taro" class="headerlink" title="tarojs/taro"></a>tarojs/taro</h2><p>taro这个包大概看下来就是提供运行时的，核心编码采用了nervjs这个玩意。<br>不好意思，这个包暂时没整明白（也许把后面的看完了，这个就明白了）<br>taro这个包相当于一个转换器的功能，但是转换规则和核心API是由分包（taro-weapp/taro-h5等）提供的。</p>
<h2 id="tarojs-taro-webapp"><a href="#tarojs-taro-webapp" class="headerlink" title="tarojs/taro-webapp"></a>tarojs/taro-webapp</h2><p>这个包是用来编译小程序的核心<br>从package.json和index.js中可以看出，他是依赖了tarojs/taro的，因此小程序的打包还是由tarojs/taro参与。<br>另外在 component 组件中可以看到对小程序的转化操作。(我准备直接贴代码)<br>我们来细细地研究一下。（代码有点长，我还是不贴了吧）</p>
<h2 id="待续。今天先写这么多。。。"><a href="#待续。今天先写这么多。。。" class="headerlink" title="待续。今天先写这么多。。。"></a>待续。今天先写这么多。。。</h2><image src="https://cdn.nlark.com/yuque/0/2019/png/197796/1555929880714-9bd885d4-0d57-4253-8c06-037a42da22fc.png"></image></div><div class="article-meta" style="max-width:1024px"></div><div class="article-comment" style="max-width:1024px"><div class="ds-thread" id="ds-thread" data-thread-key="cjxlkpuck000780w0nvk9rvu5" data-title="Taro笔记(解析)" data-url="https://bensonchen.cn/2019/04/27/Taro笔记-解析/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  // ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2019/04/27/JavaScript数据结构与算法/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2019/01/02/2018年终总结/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/472756921" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2019 B_B<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>