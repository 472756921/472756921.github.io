<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="web前端开发, Hexo, webpack, Nodejs, Reactjs, Vuejs"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>jS异步模式 - B_B</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com"><span>Github</span></a></li><li><a href="https://www.v2ex.com/"><span>V2EX</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">jS异步模式</h1><ul class="meta"><li><i class="icon icon-author"></i>BensonChen</li><li><i class="icon icon-clock"></i>19 Minutes</li><li><i class="icon icon-calendar"></i>July 2, 2019</li></ul></div></div><div class="article-content" style="max-width:1024px"><p>之前一直想学习一下JS的 异步机制 和不断进化的 异步方案，现在整理记录一下<br><a name="OBYhp"></a></p>
<h1 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h1><p>AJAX是异步？对也不对。<br>异步任务指的是，不进入主线程、而进入任务队列（task queue）的任务（JS是单线程，同步任务只能在主线程中顺序执行），只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。<br><a name="uOgcb"></a></p>
<h1 id="由AJAX开启异步之旅"><a href="#由AJAX开启异步之旅" class="headerlink" title="由AJAX开启异步之旅"></a>由AJAX开启异步之旅</h1><p>我们知道网络请求是一个耗时操作，同步网络请求会阻塞主线程，影响后续任务执行。因此，AJAX（异步请求）概念的出现很大程度上解决了当时遇到的问题（当然AJAX还解决了交互和其他的一些问题）。<br>AJAX的任务会进入任务队列执行，完成后会去通知主线程，我准备好了，调用我吧。于是乎我们传入的 function就开始执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQ AJAX</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url: myUrl,</span><br><span class="line">  type: <span class="string">'get'</span>,</span><br><span class="line">  dataType: <span class="string">'json'</span>,</span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">data, status</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;,</span><br><span class="line">  fail: <span class="function"><span class="keyword">function</span> (<span class="params">err, status</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，我们可以看到 success 和 fail ，分别传入了对应的 function 我们把它叫做回调函数（CallBack-function）。因此引入我们对于 callback 的一些学习。<br><a name="HVPoj"></a></p>
<h1 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h1><p>我们今天讲异步，但不是所有的 callback 都是异步执行的，比如数组方法 map 中的 callback 就是同步执行的。<br>我们看一个经典的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  output(<span class="string">'callback'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p>
<p>这个例子有两个不是很明显但重要的问题</p>
<ol>
<li>setTimeout由谁提供，浏览器对吧。所以他不是JS的API，对宿主环境有依赖有要求。</li>
<li>不能控制 CB 的调用。</li>
</ol>
<p>我们再看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  output(<span class="string">'one'</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    output(<span class="string">'two'</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      output(<span class="string">'three'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p>
<p>是不是有种头疼的感觉（其实还好，后面会更加头疼），我们一直讲，callback 有个比较大的问题叫做地狱回调，但实际上我没有理解到其真正的含义。<br><a name="51Wp8"></a></p>
<h2 id="地狱回调"><a href="#地狱回调" class="headerlink" title="地狱回调"></a>地狱回调</h2><p>从根本上来讲，回调地狱并非仅仅指在代码的编写上使用多层级回调函数嵌套，本质上应该是 回调函数 对于时间的控制，又或者说 同步任务 和 异步任务 的结合。<br>举个例子，我们有4个网络请求同时发出，然后需要按照顺序来显示结果，这个时候我们怎么保证顺序输出呢?，为了保证请求的并发，使用请求嵌套的方式满足不了需求，我们需要写一套非常复杂的控制方法来实现。<br>但是我们可以换个角度想，我们去不关心请求的过程，只关心得到请求结果后的展示。及我们得想办法将时间概念排除在编程之外。由此引入 thunk 这个概念<br><a name="2vRHF"></a></p>
<h1 id="Thunk"><a href="#Thunk" class="headerlink" title="Thunk"></a>Thunk</h1><p>我们来看一下 thunk 的使用。<br>thunk是一个比较老的概念，详情可以参见阮老师的<a href="http://www.ruanyifeng.com/blog/2015/05/thunk.html" target="_blank" rel="noopener">博客</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> resp</span><br><span class="line"></span><br><span class="line">  fakeAjax(file, <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!resp) resp = text</span><br><span class="line">    <span class="keyword">else</span> resp(text)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">th</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resp) cb(resp)</span><br><span class="line">    <span class="keyword">else</span> resp = cb</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> th1 = getFile(<span class="string">'file1'</span>)</span><br><span class="line"><span class="keyword">const</span> th2 = getFile(<span class="string">'file2'</span>)</span><br><span class="line"><span class="keyword">const</span> th3 = getFile(<span class="string">'file3'</span>)</span><br><span class="line"></span><br><span class="line">th1(<span class="function"><span class="keyword">function</span> <span class="title">ready</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  output(text)</span><br><span class="line">  th2(<span class="function"><span class="keyword">function</span> <span class="title">ready</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    output(text)</span><br><span class="line">    th3(<span class="function"><span class="keyword">function</span> <span class="title">ready</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">      output(text)</span><br><span class="line">      output(<span class="string">'Complete!'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>我们来研究一下上面一段代码，请求文件（getFile）后返回了一个接收callback函数的函数，我们可以简单地理解为：请求我做了，但是后续由用户自行决定。比起纯 Callback 方案，利用 thunk，我们的代码好理解很多。thunk 的本质其实是使用闭包来管理状态，因此我们不再管理复杂的时间维度。</p>
<blockquote>
<p>异步 thunk 让时间不再是问题，如果我们换个角度看 ，它就好似是给一个未来的值添加了展位符。有没有觉得这种说法似曾相识，没错，Promise 也是如此。在 Promise 中，时间也被抽离了出去。<br>虽然异步 thunk 抽离出时间后，我们的代码稍微更好理解了，但是回调的另外一个问题 — 依赖反转，通过 thunk 却难以克服。如果用人话来说「依赖反转」，其实这是一种信任问题，回调函数的调用其实是受外界控制的，其会不会被调用，会被调用几次都不能完全受我们控制。为了解决这个问题，Promise 粉墨登场。<br>——<a href="https://mp.weixin.qq.com/s/xrdEwB4uxIFhNIg5xr-X7w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/xrdEwB4uxIFhNIg5xr-X7w</a></p>
</blockquote>
<p><a name="tvmF2"></a></p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>初次接触promise，只是为了取代 callback 的回调地狱，但当我们了解回调地狱的本质后会发现，promise解决的并非 多层级嵌套造成的不便，而是对于回调函数执行的控制（Promise 的核心在于其通过一种协议保障了then后注册的函数只会被执行一次）。普通的 callback 实际上是第三方直接调用我们的函数，这个第三方不一定是完全可信的，我们的回调函数可能会被调用，也可能不会调用，还可能会调用多次。Promise 则将代码的执行控制在我们自己手里，要么成功要么失败，then后面的函数只会执行一次。<br>但是promise依旧存在一个问题，链式调用就像一列火车，一旦开启就无法控制让其停下。为此还专门讨论了一些中断Promise的方法。<br>也正是由于Promise的不可控特性，generator 光荣出厂<br><a name="OWVrZ"></a></p>
<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p>Generator 的中文名称是生成器，它是ECMAScript6中提供的新特性。在过去，封装一段函数。函数只存在“没有被调用”或者“被调用”的情况，不存在一个函数被执行之后还能暂停的情况，而Generator的出现让这种情况成为可能。<br>归纳起来 generator 函数具有以下特点：</p>
<ul>
<li>函数可暂停和继续；<br></li>
<li>可返回多个值给外部；<br></li>
<li>在继续的时候，外面也可以再传入值；<br></li>
<li>通过 Generator 写的异步代码看起来就像是同步的；</li>
</ul>
<p>generator除了return语句外，可以用yield返回多次，也可以看成generator遇到yield是就返回一个值，并且generator暂停在这，当需要继续执行是只用调用generator.next()就可以继续执行，遇到yield又会暂停，再调用generator.next()后继续执行……<br>每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。<br>value 属性是 yield 语句后面表达式的值，表示当前阶段的值；<br>done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。<br>由此，generator的作用已经很明显了。具体可以参加阮老师<a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="noopener">博客</a></p>
<p>generator 把我们的代码分割成了独立可阻塞的部分，局部的阻塞不会导致全局的阻塞，每当遇到yield就会暂停，就需要我们手动调用 .next()来继续执行后面的内容。这个方法在任何地方都可能被调用，因此又出现了在 callback 中出现过的「控制反转」问题。我们完全不知道谁会在什么地方调用.next()，结合 Promise 我们可以比较轻松的解决「控制反转」的问题，一些人把 Promise + Generator 当作是异步最好的解决方案之一。<br>看一个例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里封装的 runGenerator 可以让 generator 自动运行起来</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runGenerator</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> it = g()</span><br><span class="line">  <span class="keyword">let</span> ret</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    ret = it.next(val)</span><br><span class="line">    <span class="keyword">if</span> (!ret.done) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">'then'</span> <span class="keyword">in</span> ret.value) &#123;</span><br><span class="line">        ret.value.then(iterate)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          iterate(ret.value)</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAjaxCall</span>(<span class="params">url, cb</span>) </span>&#123;</span><br><span class="line">  setTimeout(cb(url), <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    makeAjaxCall(url, <span class="function"><span class="keyword">function</span>(<span class="params">err, text</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(err)</span><br><span class="line">      <span class="keyword">else</span> resolve(text)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runGenerator(<span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result1</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    result1 = <span class="keyword">yield</span> request(<span class="string">'http://some.url.1'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    output(<span class="string">'Error: '</span> + err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(result1)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result2</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    result2 = <span class="keyword">yield</span> request(<span class="string">'http://some.url.2?id='</span> + data.id)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    output(<span class="string">'Error: '</span> + err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse(result2)</span><br><span class="line">  output(<span class="string">'The value you asked for: '</span> + resp.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>上述代码具体来说，我们可以在 Promise 中调用 .next()，Promise 机制保证了.next() 的调用是受控制的。<br>但是对于generator来讲，每次封装一个generator函数无疑是很复杂的一件事情，因此async的出现解决了generator函数声明的复杂问题。<br><a name="o3j77"></a></p>
<h1 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h1><p>一句话，async 函数就是 Generator 函数的语法糖。但是，我们应当明确，async 函数并非一种让 generator 更便于使用的语法糖。async 函数只有在结束时，才会返回的是一个 Promise。我们无法控制其中间状态，而 generator 返回的是迭代器，迭代器让你有充分的控制权。</p>
</div><div class="article-meta" style="max-width:1024px"></div><div class="article-comment" style="max-width:1024px"><div class="ds-thread" id="ds-thread" data-thread-key="cjxlkr5cm00082kw04srdhpif" data-title="jS异步模式" data-url="https://bensonchen.cn/2019/07/02/jS异步模式/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  // ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2019/05/16/扒一扒双向数据绑定/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/472756921" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2019 B_B<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>