<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="web前端开发, Hexo, webpack, Nodejs, Reactjs, Vuejs"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>'JS读书杂记' - B_B</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com"><span>Github</span></a></li><li><a href="https://www.v2ex.com/"><span>V2EX</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">'JS读书杂记'</h1><ul class="meta"><li><i class="icon icon-author"></i>BensonChen</li><li><i class="icon icon-clock"></i>10 Minutes</li><li><i class="icon icon-calendar"></i>October 15, 2018</li></ul></div></div><div class="article-content" style="max-width:1024px"><h2 id="JS-的七种类型——类型"><a href="#JS-的七种类型——类型" class="headerlink" title="JS 的七种类型——类型"></a>JS 的七种类型——类型</h2><p>null， undefined, string, boolean, number, object, symbol<br>除了object之外，其他都叫做基本类型。</p>
<h2 id="为啥-typeof-null-‘object’-true"><a href="#为啥-typeof-null-‘object’-true" class="headerlink" title="为啥 typeof null === ‘object’;  //true"></a>为啥 typeof null === ‘object’;  //true</h2><p>这是一个JS的BUG，可能永远不会被修复。<br>原因：<br>1.对象在底层都表示为二进制<br>2.在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型<br>3.null 的二进制表示是全 0，自然前三位也是 0</p>
<h2 id="为啥-typeof-function-a-‘function’-true"><a href="#为啥-typeof-function-a-‘function’-true" class="headerlink" title="为啥 typeof function a(){} === ‘function’; //true"></a>为啥 typeof function a(){} === ‘function’; //true</h2><p>因为函数实际上是object的一个子类，是可调用的对象（ps，由于内部有 [[call]] 属性保证可以被调用 ）<br>另外 数组也是object的一个子类型</p>
<h2 id="变量是没有类型的，只有值才有"><a href="#变量是没有类型的，只有值才有" class="headerlink" title="变量是没有类型的，只有值才有"></a>变量是没有类型的，只有值才有</h2><p>JavaScript 中的变量是没有类型的，只有值才有，在对变量执行 typeof 操作时，得到的结果并不是该变量的类型，而是该变量持有的值的类型。</p>
<h2 id="undefined-和-undeclared-未声明"><a href="#undefined-和-undeclared-未声明" class="headerlink" title="undefined 和 undeclared(未声明)"></a>undefined 和 undeclared(未声明)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a)   <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b)   <span class="comment">//undeclared  (b is not defined)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span>(a)   <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">typeof</span>(b)   <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="为啥typeof-b-是undefined-–（typeof-undeclared）"><a href="#为啥typeof-b-是undefined-–（typeof-undeclared）" class="headerlink" title="为啥typeof(b)是undefined –（typeof undeclared）"></a>为啥typeof(b)是undefined –（typeof undeclared）</h2><p>typeof的安全机制作用<br>如果要判断一个变量是否已经被声明；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(testVar)&#123;</span><br><span class="line">    ...   <span class="comment">//该变量未被声明 ,</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上述做法肯定报错 ReferenceError</span></span><br><span class="line"><span class="comment">// 用typeof安全机制做</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> testVar !== <span class="string">'undefined'</span> )&#123;</span><br><span class="line">    ...   <span class="comment">//该变量已被声明 ,</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h2><p>例如 var a = ‘abcdefg’;<br>怎么样反转它，循环当然可以，不过有点low<br>我们知道字符串是没法被改变的（字符串的成员函数无法改变其原始值，而是创建一个新的值返回），but数组是可以的。<br>并且数组本身就拥有一个reverse（）函数用于反转数组<br>所以<br>1.先将字符串转成数组 (.split(‘’))<br>2.reverse()<br>3.join(‘’)</p>
<p>但是注意，如果包含了星号等复杂字符的字符串是没有办法用这个方式反转的</p>
<h2 id="0-1-0-2-0-3-false"><a href="#0-1-0-2-0-3-false" class="headerlink" title="0.1 + 0.2 === 0.3  //false"></a>0.1 + 0.2 === 0.3  //false</h2><p>因为在二进制浮点数中 0.1和0.2表示并不是十分精确的。</p>
<h2 id="不是值的值"><a href="#不是值的值" class="headerlink" title="不是值的值"></a>不是值的值</h2><p>undefined 和 null 他们既是类型又是值<br>null指空值，undefined指没有值</p>
<h2 id="不是数字的数字"><a href="#不是数字的数字" class="headerlink" title="不是数字的数字"></a>不是数字的数字</h2><p>数学运算中含有不是数字类型（无法解析为16、10进制），就返回一个NaN（not a number）<br>注意这个Nan 他是唯一一个不自返，即 NaN == NaN, NaN === NaN 均为false<br>可用isNaN方法检测，but<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'foo'</span>;</span><br><span class="line"><span class="built_in">window</span>.isNaN(a);    <span class="comment">// true</span></span><br><span class="line"><span class="comment">//显然  a 不是 NaN</span></span><br><span class="line"><span class="comment">//推荐使用ES6中的 NUmber.isNaN()</span></span><br></pre></td></tr></table></figure></p>
<h2 id="值-复制-和-引用"><a href="#值-复制-和-引用" class="headerlink" title="值 复制 和 引用"></a>值 复制 和 引用</h2><p>简单值(包括 null、undefined、字符串、数字、布尔和 symbol)总是通过值复制(value-copy)的方式来赋值/传递；<br>复合型(对象，包括数组、函数、封装对象)总是通过引用复制(reference-copy)的方式来赋值/传递。</p>
<p>我们无法自行决定使用值复制还是引用复制（且二者在语法上没有区别），一切由值的类型决定。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> b = a; <span class="comment">// b 是 a 的值的一个副本(值复制)</span></span><br><span class="line">b++;</span><br><span class="line">a; <span class="comment">// 2</span></span><br><span class="line">b; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> d = c; <span class="comment">// d 是 [1, 2, 3] 的一个引用(引用复制)</span></span><br><span class="line">d.push(<span class="number">4</span>);</span><br><span class="line">c; <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">d: <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></p>
<p>再看一个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    x.push(<span class="number">4</span>);</span><br><span class="line">    x; <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">    x = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">    x.push(<span class="number">7</span>);</span><br><span class="line">    x; <span class="comment">// [4, 5, 6, 7];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">foo(a);</span><br><span class="line">a; <span class="comment">// [1, 2, 3, 4] 不是 [4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 只会改变 a 和 x 共同指向的值，而不会改变 a 的指向，当 x 被赋新值时，指向发生了改变。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想要通过值复制的方式传递复合值，就需要为它创建一个副本，这样子传递的不再是原始值</span></span><br><span class="line"><span class="comment">// 可以通过 slice() 做一个浅副本</span></span><br></pre></td></tr></table></figure></p>
<h2 id="基本类型-和-封装对象"><a href="#基本类型-和-封装对象" class="headerlink" title="基本类型 和 封装对象"></a>基本类型 和 封装对象</h2><p>思考一个问题，var a = ‘aaa’; 和 var b = new String(‘aaa’) 和 var c = String(‘aaa’) 有什么区别；<br>其实 var a = ‘aaa’ 和 var c = String(‘aaa’) 是一样的东西， 即 a === c<br>这里主要是区别 a 和 b</p>
<ol>
<li>a 是基本类型 String</li>
<li>b 是对象 Object 创建的是字符串’aaa’的封装对象，而非基本类型值’aaa’</li>
</ol>
<p>主要说一下 var a = ‘aaa’；<br>由于基本类型值没有 .toString(),.length 这样的方法和属性， 所以JS引擎自动为a（基本类型值）包装一个 ‘封装对象’<br>注意 a 是js引擎自动包装的封装对象，其本质还是一个基本类型，不能和手动封装的 b 一样，b 实际上还是一个引用类型。</p>
<p>有个疑问，自动包装是在访问属性方法的时候进行的 还是在 LHS 进行的？？？</p>
</div><div class="article-meta" style="max-width:1024px"></div><div class="article-comment" style="max-width:1024px"><div class="ds-thread" id="ds-thread" data-thread-key="cjpew5k9l00072sw0t0q3bdvh" data-title="'JS读书杂记'" data-url="https://bensonchen.cn/2018/10/15/JS读书杂记/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  // ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2018/10/26/redux解析/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2018/05/22/柯里化/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/472756921" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2018 B_B<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>