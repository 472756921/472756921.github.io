<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="web前端开发, Hexo, webpack, Nodejs, Reactjs, Vuejs"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>'webpack读书笔记' - B_B</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com"><span>Github</span></a></li><li><a href="https://www.v2ex.com/"><span>V2EX</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">'webpack读书笔记'</h1><ul class="meta"><li><i class="icon icon-author"></i>BensonChen</li><li><i class="icon icon-clock"></i>30 Minutes</li><li><i class="icon icon-calendar"></i>November 12, 2018</li></ul></div></div><div class="article-content" style="max-width:1024px"><h1 id="为什么会有webpack"><a href="#为什么会有webpack" class="headerlink" title="为什么会有webpack"></a>为什么会有webpack</h1><p>现代web开发中模块式是一个必备解决方案，因此诞生以一些列模块式工具，诸如AMD，CMD，commonJS，ES6模块等概念和工具。</p>
<blockquote>
<p>前端模块要在客户端中执行，所以他们需要增量加载到浏览器中。<br>模块的加载和传输，我们首先能想到两种极端的方式，一种是每个模块文件都单独请求，另一种是把所有模块打包成一个文件然后只请求一次。显而易见，每个模块都发起单独的请求造成了请求次数过多，导致应用启动速度慢；一次请求加载所有模块导致流量浪费、初始化过程慢。这两种方式都不是好的解决方案，它们过于简单粗暴。<br>引自-《Webpack 中文指南》</p>
</blockquote>
<blockquote>
<p>分块传输，按需进行懒加载，在实际用到某些模块的时候再增量更新，才是较为合理的模块加载方案。要实现模块的按需加载，就需要一个对整个代码库中的模块进行静态分析、编译打包的过程。<br>引自-《Webpack 中文指南》</p>
</blockquote>
<blockquote>
<p>在编译的时候，要对整个代码进行静态分析，分析出各个模块的类型和它们依赖关系，然后将不同类型的模块提交给适配的加载器来处理。比如一个用 LESS 写的样式模块，可以先用LESS加载器将它转成一个CSS 模块，在通过 CSS 模块把他插入到页面的’style’标签中执行。Webpack 就是在这样的需求中应运而生。<br>引自-《Webpack 中文指南》</p>
</blockquote>
<h1 id="webpack-的身世"><a href="#webpack-的身世" class="headerlink" title="webpack 的身世"></a>webpack 的身世</h1><h2 id="webpack本地（局部）安装如何运行"><a href="#webpack本地（局部）安装如何运行" class="headerlink" title="webpack本地（局部）安装如何运行"></a>webpack本地（局部）安装如何运行</h2><p>在本地安装webpack后，由于没有环境变量，所以无法直接使用webpack，这个时候我们可以借助npm实现webpack的使用<br>如在package.json中配置：<br>“dev”: “webpack –mode development”.<br>“build”: “webpack –mode production”.( –mode production表示生产环境)</p>
<h2 id="什么是-Webpack"><a href="#什么是-Webpack" class="headerlink" title="什么是 Webpack"></a>什么是 Webpack</h2><p>Webpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。<br>包括：</p>
<ol>
<li>代码转换</li>
<li>文件优化（压缩文件，合并图片）</li>
<li>代码分割（提取公共代码，让首屏不需要的代码和资源异步加载）</li>
<li>模块合并</li>
<li>代码验证</li>
<li>自动发布（代码更新后，自动构建发布）</li>
</ol>
<hr>
<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader进行转换。<br>Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 require 来加载任何类型的模块或文件，比如CoffeeScript、JSX、 LESS 或图片。<br>Loader的写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;<span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>:[<span class="string">'style-loader'</span>, <span class="string">'css-loader?minimize'</span>] &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意loader的执行顺序是从后向前，先由css-loader读取css文件，再由style-loader将其注入到JS文件中。<br>每个loader都可以传入参数（URL querysting 的方式），minimize 表示开启css压缩，能够减少css部分 10%-20% 的体积。</p>
<hr>
<h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><p>Plugin是用来扩展webpack功能的。在 Webpack 构建流程中的特定时机注入扩展逻辑，来改变构建结果或做我们想要的事情。<br>这是一个Plugin的例子，用于单独打包css<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>, <span class="comment">//这个时候就不需要style-loader把CSS注入到js中了</span></span><br><span class="line">            loader:[MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">        filename: <span class="string">`[name]_[contenthash:8].css`</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h2><p>有了这个东西就可以映射源码。<br>在config中配置：devtool: ‘source-map’（与entry同级） 即可</p>
<hr>
<h2 id="webpack中的各种概念"><a href="#webpack中的各种概念" class="headerlink" title="webpack中的各种概念"></a>webpack中的各种概念</h2><p>module：模块，一个模块对应一个文件，Webpack会从entry开始，递归找出所有依赖的模块。<br>loader：模块转换器，将一个模块按照要求转化成新的内容。<br>plugins：插件，在构建流中特定的时机（取决于插件开发者，我们一般是被动的使用）注入扩展逻辑，来改变结构达到我们想要的效果。</p>
<h1 id="webpack-详细"><a href="#webpack-详细" class="headerlink" title="webpack 详细"></a>webpack 详细</h1><p>前面讲讲了一大堆，想必对webpack有了一个大致的了解，下面的部分将详细记录webpack的各种工作和功能。</p>
<h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><p>Content是寻找文件的根目录，默认启动webpack时所在的目录，可设置指定<br>content:path.resolve(__dirname, ‘XXX’),   （xxx绝对路径）</p>
<h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p>Entry是配置的模块的入口，搜寻及递归解析出所有入口依赖的模块（必填）。<br>Entry有三种配置方式</p>
<ol>
<li>string</li>
<li>array（搭配 output.library 配置项使用时，只有数组里的最后一个入口文件的模块会被导出）</li>
<li>object（配置多个入口，每个入口生成一个Chunk（代码块））</li>
</ol>
<p>entry 也可以配置成动态的方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">entry : <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        a : ’. / p ages/a ’,</span><br><span class="line">        b :’./pages/ b ’,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h3><p>可以理解为‘代码块’<br>如果entry是一个String/array，只会生成一个chunk，名字是mian<br>如果entry是一个Obj，就可能出现多个Chunk，名字是obj中的键值(key)</p>
<hr>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>filename: 输出文件名<br>如果只有一个chunk的话，filename 可使用静态string，如果是多个chunk的话则可用变量模板，例如 ‘[name].js’<br>这里的[name]是chunk内置的name变量去替换（除了name还有id，hash-&gt;hash:8，chunkhash-&gt;chunkhash:8(指定长度)）</p>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>输出的文件存放目录，必须是 string 类型的绝对路径。通常通过Node.js的 path 模块去获取绝对路径。<br>path: path.resolve(__dirname, ‘./dist’)</p>
<h3 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h3><p>在复杂的项目里可能会有一些构建出的资源需要异步加载，加载这些异步资源需要对应的URL地址。<br>publicPath: 配置发布到线上资源的 URL 前缀，为 string 类型。默认值是空字符串 ，即使用相对路径。<br>可配置IP地址，发布到CDN上</p>
<h3 id="library-和-libraryTarget"><a href="#library-和-libraryTarget" class="headerlink" title="library 和 libraryTarget"></a>library 和 libraryTarget</h3><p>这两兄弟是构建可以被其他模块导入的库时要用到的东西。<br>略过</p>
<h3 id="libraryExport"><a href="#libraryExport" class="headerlink" title="libraryExport"></a>libraryExport</h3><p>配置导出模块中哪些子模块需要被导出<br>同上略过</p>
<p>开发组件库时需要用到上面两个东西</p>
<hr>
<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>配置模块处理规则</p>
<h3 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h3><p>创建模块时，匹配请求的规则 对象数组。<br>这些规则能够修改模块的创建方式。这些规则能够对模块(module)应用 loader，或者修改解析器(parser)。</p>
<h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><p>loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。<br>loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。<br>一个 loader 主要有三个步骤(同级)</p>
<ol>
<li>匹配文件，主要使用 test（正则匹配，匹配文件格式或名称），include（配置匹配目录-缩小范围：path.resolve(__dirname, ‘src’)），exclude（配置排除目录） 三项配置。<br>以上三项配置还支持数组形式，它们是或条件。</li>
<li>使用何种手段（loader）处理<br> use：[‘xxx_loader’,’yyy_loader’]<br> or<br> use:[ { loader: xxx_loader, options: { xxx: xxx }, enforce: ‘post’ } ]</li>
<li>设置执行循序<br>默认use中的 loader 执行循序是从后往前，我们可以通过 enforce 来设置 第一个（pre）或最后一个（post）执行。<br>注意这个配置只能在 loader 使用对象的时候添加。</li>
</ol>
<h3 id="noParse"><a href="#noParse" class="headerlink" title="noParse"></a>noParse</h3><p>防止 webpack 解析那些任何与给定正则表达式相匹配的文件。<br>noParse: /jquery|chartjs/    不使用webpack处理匹配到的这两个文件。<br>特别注意：被排除的文件中不应该含有 import, require, define 的调用，或任何其他导入机制，否知浏览器直接调用将会无法解析。</p>
<h3 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h3><p>控制哪些模块语法被解析，哪些不被解析（相比noParse对文件的控制，这个家伙是在语法层面上做控制）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">parser: &#123;</span><br><span class="line">  amd: <span class="literal">false</span>, <span class="comment">// 禁用 AMD</span></span><br><span class="line">  commonjs: <span class="literal">false</span>, <span class="comment">// 禁用 CommonJS</span></span><br><span class="line">  system: <span class="literal">false</span>, <span class="comment">// 禁用 SystemJS</span></span><br><span class="line">  harmony: <span class="literal">false</span>, <span class="comment">// 禁用 ES2015 Harmony import/export</span></span><br><span class="line">  requireInclude: <span class="literal">false</span>, <span class="comment">// 禁用 require.include</span></span><br><span class="line">  requireEnsure: <span class="literal">false</span>, <span class="comment">// 禁用 require.ensure</span></span><br><span class="line">  requireContext: <span class="literal">false</span>, <span class="comment">// 禁用 require.context</span></span><br><span class="line">  browserify: <span class="literal">false</span>, <span class="comment">// 禁用特殊处理的 browserify bundle</span></span><br><span class="line">  requireJs: <span class="literal">false</span>, <span class="comment">// 禁用 requirejs.*</span></span><br><span class="line">  node: <span class="literal">false</span>, <span class="comment">// 禁用 __dirname, __filename, module, require.extensions, require.main 等。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><p>能设置模块如何被解析（就是如果找到模块）。<br>我们在开发中会用到 import， require 等方法来导入模块，resolve 就是用来设置如何找到对应模块的配置。<br>它大概需要这么几个属性</p>
<h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>路径映射：创建 import 或 require 的别名，来确保模块引入变得更简单。例如，一些位于 src/ 文件夹下的常用模块：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  Utilities: path.resolve(__dirname, <span class="string">'./src/utilities/'</span>),</span><br><span class="line">  components: path.resolve(__dirname, <span class="string">'./src/components/'</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用 before</span></span><br><span class="line"><span class="keyword">import</span> Utility <span class="keyword">from</span> <span class="string">'../../utilities/utility'</span>;</span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'./src/components/button'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">import</span> Utility <span class="keyword">from</span> <span class="string">'Utilities/utility'</span>;</span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'components/button'</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="mainFields"><a href="#mainFields" class="headerlink" title="mainFields"></a>mainFields</h3><p>配置优先使用的代码版本<br>mainFiels: [ ‘jsnext: main’, ‘browser’, ‘main’ ];<br>其中, jsnext:main 代表使用 ES6 的代码， main 使用 ES5 的代码。<br>只要按顺序找到其中的第一个就使用，并停止查找</p>
<h3 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h3><p>补偿 import 或 require 等方式引入文件的后缀<br>默认 extensions: [‘js’, ‘json’]</p>
<hr>
<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>扩展webpack功能的, 这玩意儿主要依赖社区开发，所有要了解各种 plugin 的方法参数，带入写法都是一致的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">        filename: <span class="string">`[name]_[contenthash:8].css`</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CommonChunkPlugin(&#123;</span><br><span class="line">        name: <span class="string">'common'</span>,</span><br><span class="line">        chunks: [ <span class="string">'a'</span>, <span class="string">'b'</span> ],</span><br><span class="line">    &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>了解更多的 plugin 用法，需要详细到各个 plugin 的开发文档中去了解。</p>
<hr>
<h2 id="DevServer"><a href="#DevServer" class="headerlink" title="DevServer"></a>DevServer</h2><p>这个也可以写入配置文件，BUT 这个东西只能是通过 DevServer 启动 webpack 的时候才会生效。</p>
<h3 id="hot"><a href="#hot" class="headerlink" title="hot"></a>hot</h3><p>热更新，注意实现方式</p>
<font color="red">他是通过用新的模块来替换旧的模块来实现实时预览功能的，不是刷新</font>

<p>在hot:false的情况系下，DevServer 默认是通过刷新整个页面来实现实时预览的。</p>
<h3 id="historyApiFallback"><a href="#historyApiFallback" class="headerlink" title="historyApiFallback"></a>historyApiFallback</h3><p>单页应用路由命中时都要求返回一个 index.html 文件，然后将 JS 代码注入。<br>如果我们的应用有多个单页组成，那么根据路由的不同，要求返回不同的 index.html，这个时候我们就要使用这个家伙了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">historyApiFallback: &#123;</span><br><span class="line">    rewrites: [</span><br><span class="line">        &#123; <span class="attr">from</span>: <span class="regexp">/^/u</span>ser/, <span class="attr">to</span>: <span class="string">'/user.html'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">from</span>: <span class="regexp">/^/</span>list/, <span class="attr">to</span>: <span class="string">'/list.html'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">from</span>: <span class="regexp">/^/</span>test/, <span class="attr">to</span>: <span class="string">'/test.html'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">from</span>: <span class="regexp">/./</span>, <span class="attr">to</span>: <span class="string">'/index.html'</span> &#125;,    <span class="comment">//其他的路由都返回 index.html</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="host-port"><a href="#host-port" class="headerlink" title="host, port"></a>host, port</h3><p>设置地址（默认 127.0.0.1）和端口（默认 8080，如果被占用，向上加 1）</p>
<h3 id="disableHostCheck"><a href="#disableHostCheck" class="headerlink" title="disableHostCheck"></a>disableHostCheck</h3><p>访问 DevServer 时会对访问者的 HOST 进行检查，默认只接受本地访问。<br>关闭这个选型，能够让其他设备访问自己的本地服务，服务器就不会再去检查host，如果不关闭的话，由于其他设备是通过 IP 访问， 一般情况下是不会在host列表中，就会造成不能访问。</p>
<h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>DevServer 会自动生成一套证书。<br>甚至于可以配置证书<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    https: <span class="literal">true</span>,</span><br><span class="line">    https: &#123;</span><br><span class="line">        key: <span class="string">''</span>,</span><br><span class="line">        cert: <span class="string">''</span>,</span><br><span class="line">        ca: <span class="string">''</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上二选一</span></span><br></pre></td></tr></table></figure></p>
<h3 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h3><p>开启 Gzip 压缩，默认false</p>
<h3 id="open-openPage"><a href="#open-openPage" class="headerlink" title="open openPage"></a>open openPage</h3><p>open 开启打开浏览器<br>openPage 打开的URL</p>
<h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>代理到后端的接口<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">    <span class="string">'/api'</span>: <span class="string">'http:xxxx.com/xxx:30'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p>开启构建性能信息，分析构建性能</p>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>开启缓存来提升构建速度。</p>
<h3 id="Watch-WatchOption"><a href="#Watch-WatchOption" class="headerlink" title="Watch WatchOption"></a>Watch WatchOption</h3><p>监听文件更新，DevServer 默认开启<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WatchOption:&#123;</span><br><span class="line">    ignored: <span class="regexp">/XXXX/</span>,         <span class="comment">// 不监听的文件夹</span></span><br><span class="line">    aggregateTimeOut: <span class="number">400</span>，  <span class="comment">// 400MS后再去重新编译，本质是截流</span></span><br><span class="line">    poll: <span class="number">1000</span>               <span class="comment">// 每秒 1000 次询问更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><h3 id="target"><a href="#target" class="headerlink" title="target"></a>target</h3><p>构建不同环境的代码</p>
<ol>
<li>web</li>
<li>node</li>
<li>async-node  异步加载 Chunk 代码</li>
<li>webworker<br>由于不同环境，打包过程会有一些不同。</li>
</ol>
<h3 id="Externals"><a href="#Externals" class="headerlink" title="Externals"></a>Externals</h3><p>打包过程排除掉的模块，通常用于第三方库。<br>举个栗子： jQuery<br>如果使用了 import $ from ‘jquery’，<br>在最后打包的文件中，会将 JQ 的内容完整的注入进去，但显然我们并不想这样子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">  jquery: <span class="string">'jQuery'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 这样子我们就把 Jq 排除在了打包文件之外。</span></span><br></pre></td></tr></table></figure></p>
<p>再来说打包后对 JQuery 的使用。<br>在引用 JQuery 后，会在全局（global）生成一个 jQuery 全局对象（注意大小写），externals 的工作实际上就是当 require 的参数是 jquery 的时候，使用 jQuery 这个全局变量引用它。<br>打包后的源码中会有这样一句<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">...</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注意这里的 jQuery 指全局变量</span></span><br><span class="line">    <span class="comment">// 因此我们 打包后源码使用 require 来引入 jquery 时，会直接使用全局变量 jQuery。</span></span><br><span class="line">    <span class="built_in">module</span>.exports = jQuery;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="webpack-多种配置写法"><a href="#webpack-多种配置写法" class="headerlink" title="webpack 多种配置写法"></a>webpack 多种配置写法</h1><h2 id="function-写法"><a href="#function-写法" class="headerlink" title="function 写法"></a>function 写法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">env = &#123;&#125;, argv</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> plugins = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isProduction = env[<span class="string">'production'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在生成环境才压缩</span></span><br><span class="line">  <span class="keyword">if</span> (isProduction) &#123;</span><br><span class="line">    plugins.push(</span><br><span class="line">      <span class="comment">// 压缩输出的 JS 代码</span></span><br><span class="line">      <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">        <span class="comment">// 最紧凑的输出</span></span><br><span class="line">        beautify: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// 删除所有的注释</span></span><br><span class="line">        comments: <span class="literal">false</span>,</span><br><span class="line">        compress: &#123;</span><br><span class="line">          <span class="comment">// 在UglifyJs删除没有用到的代码时不输出警告</span></span><br><span class="line">          warnings: <span class="literal">false</span>,</span><br><span class="line">          <span class="comment">// 删除所有的 `console` 语句，可以兼容ie浏览器</span></span><br><span class="line">          drop_console: <span class="literal">true</span>,</span><br><span class="line">          <span class="comment">// 内嵌定义了但是只用到一次的变量</span></span><br><span class="line">          collapse_vars: <span class="literal">true</span>,</span><br><span class="line">          <span class="comment">// 提取出出现多次但是没有定义成变量去引用的静态值</span></span><br><span class="line">          reduce_vars: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// JS 执行入口文件</span></span><br><span class="line">    entry: <span class="string">'./main.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">      <span class="comment">// 把所有依赖的模块合并输出到一个 bundle.js 文件</span></span><br><span class="line">      filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">      <span class="comment">// 输出文件都放到 dist 目录下</span></span><br><span class="line">      path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: plugins,</span><br><span class="line">    <span class="comment">// 在生成环境不输出 Source Map</span></span><br><span class="line">    devtool: isProduction ? <span class="literal">undefined</span> : <span class="string">'source-map'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// script 配置</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build:dev"</span>: <span class="string">"webpack"</span>,</span><br><span class="line">    <span class="string">"build:dist"</span>: <span class="string">"webpack --env.production"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<font color="red">特别注意：在webpack4 中不再自定义环境参数，需要使用 –mode 作为开发/生成环境的区别</font>

</div><div class="article-meta" style="max-width:1024px"></div><div class="article-comment" style="max-width:1024px"><div class="ds-thread" id="ds-thread" data-thread-key="cjp472xf5000ae8w0q77c30qs" data-title="'webpack读书笔记'" data-url="https://bensonchen.cn/2018/11/12/webpack读书笔记/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  // ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2018/11/28/hello-world/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2018/10/26/redux解析/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/472756921" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2018 B_B<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>