<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="web前端开发, Hexo, webpack, Nodejs, Reactjs, Vuejs"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>'一些杂记' - B_B</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com"><span>Github</span></a></li><li><a href="https://www.v2ex.com/"><span>V2EX</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">'一些杂记'</h1><ul class="meta"><li><i class="icon icon-author"></i>BensonChen</li><li><i class="icon icon-clock"></i>22 Minutes</li><li><i class="icon icon-calendar"></i>May 3, 2018</li></ul></div></div><div class="article-content" style="max-width:1024px"><h3 id="记录一些乱七八糟，零零碎碎的东西"><a href="#记录一些乱七八糟，零零碎碎的东西" class="headerlink" title="记录一些乱七八糟，零零碎碎的东西"></a>记录一些乱七八糟，零零碎碎的东西</h3><h2 id="响应式设计（RWD）和自适应设计（AWD）的区别"><a href="#响应式设计（RWD）和自适应设计（AWD）的区别" class="headerlink" title="响应式设计（RWD）和自适应设计（AWD）的区别"></a>响应式设计（RWD）和自适应设计（AWD）的区别</h2><p>响应式的服务不知道访问设备是什么，直接搞一大包代码回去，由浏览器根据断点看着办。拥有一套代码；<br>自适应的服务器知道访问设备是啥，给他返回最合适的那一套代码回去。拥有多套代码；并且，在以往的自适应布局中，他的布局结构是不会发生变化的。</p>
<h2 id="兼容retina屏幕（视网膜屏幕）"><a href="#兼容retina屏幕（视网膜屏幕）" class="headerlink" title="兼容retina屏幕（视网膜屏幕）"></a>兼容retina屏幕（视网膜屏幕）</h2><p>这个通常在移动端的开发的时候会遇到，具体去区别在于普通屏幕的1个像素的物理单位只包含1个像素，儿视网膜屏中会包含4个像素点。<br>图片解决方案：采用2倍标准大小图片</p>
<h2 id="为何要使用-translate-而非-absolute-position"><a href="#为何要使用-translate-而非-absolute-position" class="headerlink" title="为何要使用 translate() 而非 absolute position"></a>为何要使用 translate() 而非 absolute position</h2><p>translate可以用上GPU参与运算，而且计算单位是比px更小的deg</p>
<h2 id="css动画和js动画的区别"><a href="#css动画和js动画的区别" class="headerlink" title="css动画和js动画的区别"></a>css动画和js动画的区别</h2><p>js走主线程，可能有阻塞；但其控制力比css好。<br>优化CSS动画性能也可通过提前声明transform来让GPU参与绘制和运算</p>
<h2 id="JS事件循环"><a href="#JS事件循环" class="headerlink" title="JS事件循环"></a>JS事件循环</h2><p>这个需要抽象一点的理解。<br>假定我们有三个容器<br>1.主线程容器<br>2.异步处理容器<br>3.任务队列</p>
<p>首先主线程容器开跑，如果遇到了异步API就把他扔到异步处理容器里，自己接着干不费时的操作。<br>被扔到异步容器里的任务，开始执行，得到结果后，它就跳到了任务队列里面。<br>当主线程没事儿的时候，就去看看任务队列，如果里面有东西，就取一个任务出来干。</p>
<p>以上3步不断地重复地执行，就叫事件循环</p>
<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p>这两个实际上是运用的了闭包的原理。<br>细看代码，这是一个简单的拖动事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> t = <span class="built_in">document</span>.getElementById(<span class="string">'aaa'</span>);</span><br><span class="line"> t.onmousedown = <span class="function"><span class="keyword">function</span> (<span class="params">et</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> h = et.clientY - t.offsetTop;</span><br><span class="line">     <span class="keyword">var</span> w = et.clientX - t.offsetLeft;</span><br><span class="line">     t.onmousemove = throttle(changePosition, <span class="number">16</span>, w, h)</span><br><span class="line">     t.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         t.onmousemove = <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//防抖</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, w, h</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> timeout;</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">         <span class="keyword">var</span> e = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">         clearTimeout(timeout)</span><br><span class="line">         timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             func.call(context, e, w, h)</span><br><span class="line">         &#125;, wait);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//节流</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, w, h</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> timeout;</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">         <span class="keyword">var</span> e = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">         <span class="keyword">if</span>(!timeout) &#123;</span><br><span class="line">             timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                 timeout = <span class="literal">null</span>;</span><br><span class="line">                 func.call(context, e, w, h)</span><br><span class="line">             &#125;, wait);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">changePosition</span>(<span class="params">e, w, h</span>) </span>&#123;</span><br><span class="line">     t.style.left = e.clientX - w + <span class="string">'px'</span>;</span><br><span class="line">     t.style.top = e.clientY - h + <span class="string">'px'</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意节流和防抖的区别<br>节流： 先干着，在干的过程中有新的来，忽略掉。<br>防抖：停止触发事件后再干。</p>
<h2 id="webpack-4-中使用命令行打包-需要指定output参数-在没有配置文件的情况下"><a href="#webpack-4-中使用命令行打包-需要指定output参数-在没有配置文件的情况下" class="headerlink" title="webpack 4 中使用命令行打包 需要指定output参数(在没有配置文件的情况下)"></a>webpack 4 中使用命令行打包 需要指定output参数(在没有配置文件的情况下)</h2><p>eg：webpack entry.js –output-filename bundle.js –output-path .</p>
<h2 id="import和require的区别"><a href="#import和require的区别" class="headerlink" title="import和require的区别"></a>import和require的区别</h2><h4 id="遵循规范"><a href="#遵循规范" class="headerlink" title="遵循规范"></a>遵循规范</h4><p>require 是 AMD规范引入方式<br>import 是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法</p>
<h4 id="调用时间"><a href="#调用时间" class="headerlink" title="调用时间"></a>调用时间</h4><p>require 是运行时调用，所以require理论上可以运用在代码的任何地方<br>import 是编译时调用，所以必须放在文件开头</p>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>require 是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量<br>import 是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require</p>
<h2 id="垂直居中的三种方法"><a href="#垂直居中的三种方法" class="headerlink" title="垂直居中的三种方法"></a>垂直居中的三种方法</h2><ol>
<li>top/right/left/bottom:0; absolute; margin:auto;</li>
<li>position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);</li>
<li>flex(IE9不兼容);</li>
</ol>
<h2 id="css-checked"><a href="#css-checked" class="headerlink" title="css checked"></a>css checked</h2><p>选择器匹配每个选中的输入元素（仅适用于单选按钮或复选框）。<br>如<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#test:checked&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"Car"</span> <span class="attr">id</span>=<span class="string">"test"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当input选中时，宽度就会变咯</p>
<h2 id="es6中的各种数组方法"><a href="#es6中的各种数组方法" class="headerlink" title="es6中的各种数组方法"></a>es6中的各种数组方法</h2><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><ol>
<li>new Set(arr)</li>
<li>const res = new Map(); arr.filter((a) =&gt; !res.has(a) &amp;&amp; res.set(a, 1));</li>
</ol>
<h3 id="数组函数-reduce，对数组前后两项进行某种计算。"><a href="#数组函数-reduce，对数组前后两项进行某种计算。" class="headerlink" title="数组函数 reduce，对数组前后两项进行某种计算。"></a>数组函数 reduce，对数组前后两项进行某种计算。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> temp = array.reduce(<span class="function">(<span class="params">x, y, index</span>) =&gt;</span> &#123;</span><br><span class="line">　　<span class="built_in">console</span>.log(<span class="string">"x"</span>: x);</span><br><span class="line">　　<span class="built_in">console</span>.log(<span class="string">"y"</span>: y);</span><br><span class="line">　　<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(temp);　　<span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(array);　　<span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// x 是上一次计算过的值, 第一次循环的时候是数组中的第1个元素</span></span><br><span class="line"><span class="comment">// y 是数组中的每个元素, 第一次循环的时候是数组的第2个元素</span></span><br></pre></td></tr></table></figure>
<h3 id="数组检测"><a href="#数组检测" class="headerlink" title="数组检测"></a>数组检测</h3><ol>
<li>every  遍历数组, 每一项都是true, 则返回true, 只要有一个是false, 就返回false, 并停止循环</li>
<li>some  遍历数组的每一项, 有一个返回true, 则返回true, 并停止循环</li>
</ol>
<h2 id="es6-的-Proxies方法"><a href="#es6-的-Proxies方法" class="headerlink" title="es6 的 Proxies方法"></a>es6 的 Proxies方法</h2><p>Proxy 是一个全局对象，可以直接使用。Proxy(target, handler) 是一个构造函数调用，Proxies接收两个参数 （target，handlder）target 是被代理的对象，handlder 是声明了各类代理操作的对象，最终返回一个代理对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    name: <span class="string">'Billy Bob'</span>,</span><br><span class="line">    age: <span class="number">15</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    get(target, key, proxy) &#123;</span><br><span class="line">        <span class="keyword">const</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`GET request made for <span class="subst">$&#123;key&#125;</span> at <span class="subst">$&#123;today&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> py = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">py.name;</span><br></pre></td></tr></table></figure></p>
<h2 id="em-rem"><a href="#em-rem" class="headerlink" title="em rem"></a>em rem</h2><p>em：相对于当前对象内文本的字体尺寸<br>rem：相对的只是HTML根元素的字体尺寸</p>
<h2 id="css3过渡（transition）和动画的区别（animation）"><a href="#css3过渡（transition）和动画的区别（animation）" class="headerlink" title="css3过渡（transition）和动画的区别（animation）"></a>css3过渡（transition）和动画的区别（animation）</h2><p>Transition 强调过渡，Transition ＋ Transform ＝ 两个关键帧的Animation<br>Animation 强调流程与控制，Duration ＋ TransformLib ＋ Control ＝ 多个关键帧的Animation</p>
<h2 id="function的三种定义方式和区别"><a href="#function的三种定义方式和区别" class="headerlink" title="function的三种定义方式和区别"></a>function的三种定义方式和区别</h2><p>1.声明函数 （在代码执行前就被解释器加载到作用域中-有提升）<br>    讲讲原因：在js中逻辑是先声明，后赋值。js在编译过程中会先查找所有的声明，完了之后会把代码交给引擎执行，这个时候引擎就会先查找（这里是作用域链查找）再使用这个变量，并将值赋给它。<br>2.函数表达式 （在执行到代码时才加载函数的-无提升）<br>3.构造函数（var f = new function (‘x’, ‘y’, ‘return x+y’)）</p>
<h2 id="es6里箭头函数的一些小细节"><a href="#es6里箭头函数的一些小细节" class="headerlink" title="es6里箭头函数的一些小细节"></a>es6里箭头函数的一些小细节</h2><p>1.this指向调用对象的this，不会再改变<br>2.不能作为构造调用<br>3.不能当做Generator函数,不能使用yield关键字<br>4.箭头函数不绑定arguments,取而代之用rest参数</p>
<h2 id="js事件循环机制"><a href="#js事件循环机制" class="headerlink" title="js事件循环机制"></a>js事件循环机制</h2><p>事件循环机制呢，简单点来说，就是在执行上下文的过程中，对函数的入栈和出栈。<br>执行前函数先入栈，执行完后函数出栈。如若遇到了一些异步操作像回调函数以及ajax、setTimeout等，会先将他们交给浏览器的其他模块去执行，执行完后，会把回调函数放入到taskqueue中。当所有的call stack执行完后再开始执行task queue中的函数。</p>
<h2 id="JS调用栈（Call-Stack）"><a href="#JS调用栈（Call-Stack）" class="headerlink" title="JS调用栈（Call Stack）"></a>JS调用栈（Call Stack）</h2><p>js调用栈个逻辑是后进先出，来个栗子；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">    c();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure></p>
<p>调用栈从下往上的结构是：a -&gt; b -&gt; c<br>首先 a 会被加入到调用栈的顶部，然后，因为 a 内部调用了 b，紧接着 b 被加入到调用栈的顶部，当 b 内部调用 c 的时候也是类似的。<br>在 c 执行完毕之后，c 被从调用栈中移除，控制流回到 b 上，调用栈会变成：a -&gt; b，然后 b 执行完之后，调用栈会变成：a，当 a 执行完，也会被从调用栈移除。</p>
<h2 id="JS的优化"><a href="#JS的优化" class="headerlink" title="JS的优化"></a>JS的优化</h2><p>js的优化可以从这几个点去考虑：<br>1.数据存取<br>2.DOM编程<br>3.算法和流程控制<br>参考 ：<a><a href="https://www.w3ctech.com/topic/1945" target="_blank" rel="noopener">https://www.w3ctech.com/topic/1945</a></a></p>
<h2 id="div两端宽度固定中间自适应的三种方法"><a href="#div两端宽度固定中间自适应的三种方法" class="headerlink" title="div两端宽度固定中间自适应的三种方法"></a>div两端宽度固定中间自适应的三种方法</h2><ol>
<li>采用计算方式calc （IE9+）；</li>
<li>两边采用浮动，中间设置margin；（注意div放置顺序 r+l+c）</li>
<li>两边采用absolute，中间设置margin；（注意div放置顺序 r+l+c）</li>
</ol>
<h2 id="微信模板消息中文格式问题"><a href="#微信模板消息中文格式问题" class="headerlink" title="微信模板消息中文格式问题"></a>微信模板消息中文格式问题</h2><p>在node发送post请求（模板消息）到微信时，出现了格式错误，排查后发现是由于中文导致的格式问题。<br>但是这个并不是由于编码的问题造成的，是由于在发送请求时添加了headers：{Content-Length} Content-Length 和实际请求体长度不匹配造成的。<br>最初我使用JSON.stringify(a).lenght计算请求体长度，BUT这个玩意是计算a的字符数；<br>但是在Content-Length中需要的字节数，所以字节数和请求体不匹配，微信不断返回格式错误。<br>改为Buffer.byteLength(JSON.stringify(data), ‘utf8’)后正常</p>
<h2 id="xss跨站脚本攻击"><a href="#xss跨站脚本攻击" class="headerlink" title="xss跨站脚本攻击"></a>xss跨站脚本攻击</h2><p>这个攻击行为是一种网站应的安全漏洞攻击，是代码注入的一种。<br>原则：宁死也不让数据变成可执行的代码，不信任任何用户的数据，严格区分数据和代码。</p>
<h2 id="CSRF跨站请求伪造"><a href="#CSRF跨站请求伪造" class="headerlink" title="CSRF跨站请求伪造"></a>CSRF跨站请求伪造</h2><p>1.用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；<br>2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；并且，此后从用户浏览器发送请求给网站A时都会默认带上用户的Cookie信息；<br>3.用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；<br>4.网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；<br>5.浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。</p>
<p>原则： 1.验证http Referer字段 2.HTTP头中自定义token</p>
<h2 id="CSS-中-link-和-import-的区别"><a href="#CSS-中-link-和-import-的区别" class="headerlink" title="CSS 中 link 和@import 的区别"></a>CSS 中 link 和@import 的区别</h2><p>1.引入方式：link是html标签，通过在html文件中引入，@import在css文件中引入<br>2.兼容性：link没有兼容性问题，@import 需要在IE5以上才生效<br>3.加载顺序：link是在加载html文档的时候加载，而如果@import是在外联的css文件中使用，那么@import引入顺序就是在最后面了。<br>4.优先级：link方式的样式的权重 高于@import的权重.</p>
<h2 id="src-与-href-的区别"><a href="#src-与-href-的区别" class="headerlink" title="src 与 href 的区别"></a>src 与 href 的区别</h2><p>src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。<br>src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置。<br>href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的超链接。</p>
<h2 id="…-解疑"><a href="#…-解疑" class="headerlink" title="… 解疑"></a>… 解疑</h2><ol>
<li><p>rest参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun1 = <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="built_in">console</span>.log(...args)</span><br><span class="line"> fun1(<span class="number">1</span>,<span class="string">'Good'</span>)</span><br><span class="line"><span class="comment">// 结果输出 1, Good</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展运算符（spread）<br>其作用是把一系列的函数，组装生成一个新的函数，并且从后到前，后面参数的执行结果作为其前一个的参数。</p>
</li>
</ol>
<h2 id="CommomJS-AMD-CMD"><a href="#CommomJS-AMD-CMD" class="headerlink" title="CommomJS AMD CMD"></a>CommomJS AMD CMD</h2><p><font color="red">CommonJS, AMD, CMD都是JS模块化的规范。</font></p>
<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>是服务器端js模块化的规范，同步的模块加载–(代表：NodeJS)</p>
<h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>是浏览器端js模块化的规范，提前执行（异步加载：依赖先执行）–(代表：RequireJS)</p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>也是浏览器端js模块化的规范，延迟执行（运行到需加载，根据顺序执行）–(代表：SeaJS)</p>
<h3 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h3><p>我们常用的 import 引入模块方式是 ES6模块设计;在ES6模块化出现后，将逐步地取代commonJS和AMD，成为浏览器和服务器的通用模块化解决方案。<br>但是ES6模块无法直接运行在浏览器环境，需要转成ES5后才能正常运行。</p>
</div><div class="article-meta" style="max-width:1024px"></div><div class="article-comment" style="max-width:1024px"><div class="ds-thread" id="ds-thread" data-thread-key="cjp8bcu1u0009ggw0ebtacl2s" data-title="'一些杂记'" data-url="https://bensonchen.cn/2018/05/03/一些杂记/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  // ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2018/05/22/柯里化/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2018/05/02/JS中的This/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/472756921" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2018 B_B<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>